---
title: "Regression diagnostics: outlier detection with Mahalanobis ellipse"
author: "Andrej Blejec"
date: "October 14, 2020"
output: html_document
---

```{r include=FALSE}
knitr::opts_chunk$set(fig.path='./figs/',tidy=TRUE, dev=c("png","tiff","pdf"))
knitr::opts_knit$set(concordance=TRUE)
```


```{r Author:,echo=FALSE}
###############################################
##                                           ##
## (c) Andrej Blejec (andrej.blejec@nib.si)  ##
##                                           ##
###############################################
```

```{r initialize,echo=FALSE,results='hide',message=FALSE}
options(width=70)
```
## Data

Data for this example are from the time and area overlap study.

```{r}
library(wrapr)
Y <- wrapr::build_frame(
   "label"  , "pa"   , "pt"    |
     "C2"   , 0.08554, 0.1057  |
     "F6"   , 0.07524, 0.09598 |
     "T19"  , 0.3027 , 0.3138  |
     "T3"   , 0.06263, 0.1599  |
     "F4"   , 0.04419, 0.04419 |
     "C1"   , 0.1254 , 0.1492  |
     "T1"   , 0.4342 , 0.5174  |
     "T20"  , 0.3598 , 0.3598  |
     "F5"   , 0.1046 , 0.1046  )
rownames(Y) <- Y$label
X <- Y[,-1]
knitr::kable(X)
```


Function to plot Mahalanobis ellipses
```{r }
#' Draw Mahalanobis elliptical data envelopes
#'
#' @param x data frame, first two columns will be used for plotting
#' @param points logical, if TRUE, points will be plotted
#' @param seg logical, if TRUE segments showing the distance from PCA will be plotted
#' @param q numeric vector, cumulative probabilities of ellipses
#' @param ltys vector of line types for ellipses
#' @param cex vector of point sizes
#' @param cex vector of point colors
#' @param colp vector of point colors
#' @param bold character label for which bold font typface will be used
#' @param dx numeric vector of label displacements in horizontal direction
#' @param dy numeric vector of label displacements in vertical direction
#' @param ... additional graphical parameters, passed to \code{plot}, \code{lines}, and \code{text}
#' @return principal component object for plotted pair of variables
#' @export
#' @seealso \code{\link{par}}
#' @note
#' @title Mahalanobis ellipses
#' @author Andrej Blejec \email{andrej.blejec@nib.si}
#' @examples
#' data <- data.frame(x=rnorm(10), y=rnorm(10))
#' rownames(data) <- LETTERS[1:10]
#' mellipse(data)
#' mellipse(data, seg=FALSE, dx=0.1)

mellipse <- function(x
    , points = TRUE
    , seg = TRUE
    , q=c(0.05, .25, .50, .75, .95)
    , xlab= names(x)[1]
    , ylab = names(x)[2]
    , ltys=rep(1,length(q))
    , cex = 1 
    , col = 1
    , colp = 1 # barve za points
    , bold = ""
    , dx = 0
    , dy = 0
    , ...){
# we start from points on the unit circle
n_points <- 100
n <- nrow(x)
sigma <- cov(x)
theta <- colMeans(x)
X <- sweep(x,2,theta,"-")
xy <- cbind(sin(seq(0, 2 * pi, length.out = n_points)),
            cos(seq(0, 2 * pi, length.out = n_points)))

# then we scale the dimensions
ev <- eigen(sigma)
xy[, 1] <- xy[, 1] * 1
xy[, 2] <- xy[, 2] * sqrt(min(ev$values) / max(ev$values))
# then rotate
phi <- atan(ev$vectors[2, 1] / ev$vectors[1, 1])
R <- matrix(c(cos(phi), sin(phi), -sin(phi), cos(phi)), 2)
xy <- tcrossprod(R, xy)
# the quantiles you ask for
chi_vals <- qchisq(q, df = 2) * max(ev$values)

#####
# Plot contours
par(mar = c(4.5, 4, .5, .5),pty="s")
plot(x[,1],x[,2], type = "n", xlab = xlab, ylab = ylab, asp=1, ...)
for(ii in 1:length(sqrt(chi_vals))) {
  r <- sqrt(chi_vals)[ii]
  lines(r * xy[1, ] + theta[1], r * xy[2, ] + theta[2], lty = ltys[ii], ...)
}
fonts <- rep(1,length=nrow(x))
names(fonts) <- rownames(x)
  if(any(rownames(x)%in% bold)) {
    fonts[bold] <- 2
#    text(x[bold,1],x[bold,2], bold, col=colp, font=2, cex=cex,  ...)
  }
# Main axis
x1 <- max(sqrt(chi_vals)) * xy[1, ] + theta[1]
y1 <- max(sqrt(chi_vals)) * xy[2, ] + theta[2]
segments(min(x1),min(y1), max(x1)*1.1, max(y1)*1.1, col=8)
# second axis
#x1 <- max(sqrt(chi_vals)) * xy[1, ] + theta[1]
#y1 <- max(sqrt(chi_vals)) * xy[2, ] + theta[2]
#segments(min(x1),min(y1), max(x1), max(y1), col=8)
#
if (points) {
  points(x[,1], x[,2],pch=16,cex=cex, col=col)
  text(x[,1]+dx,x[,2]+dy, rownames(x), col=colp, cex=cex, font=fonts, ...)

}
# Deviations

    PCX <- function(X, which=1) {
    PC <- eigen(cov(X))
    PC1 <- as.matrix(X)%*%PC$vectors[,which]
    PCX <- cbind(PC1,0)%*%solve(PC$vectors)
    colnames(PCX) <- paste0("PC",1:ncol(PCX))
    return(PCX)
}
PC <- PCX(X)
PC <- sweep(PC,2,theta,"+")
if(seg){
points(PC[,1],PC[,2],col=2, type="b")
segments(x[,1],x[,2],PC[,1],PC[,2],col=2,lwd=2)
}
invisible(prcomp(x))
}
# enter image description here
#nellipse(X)
#nellipse(X, seg=FALSE, cex=1:2)

```

Create Figure 
```{r zeroTruncatedEllipsePercLarge, fig.cap="Ellipses (zero tuncated) encompassing 68% and 95% of values"}
par(mar=c(0.1,0.2,0.1,0.1)*2)
#         "C2"  "F6"  "T19" "T3"  "F4"  "C1"  "T1"  "T20" "F5"
dxs <- c(0,    -1.2,  -1.5,  -1.2,  -1.2,   1.2,  1.2,  -1.5, 1.1 )#,    1,   1.2, -0.5,  -1,   1.2)
dys <- c(  1,    0,     0,    1.2,    0,    0,    0,     0,   0   )#,    0,    0  ,  0  ,  0,   0) 
names(dxs) <- rownames(X)
names(dys) <- rownames(X)
#

dxs <- dxs[rownames(X)]
dys <- dys[rownames(X)]
cexs <- rep(1.5, nrow(X))
cexs[rownames(X)=="T3"] <- 2
#
mellipse(X*100                       
    , q = c(0.68,0.95)
    , seg = FALSE
    , ylab = "Overlap in time (%)"
    , xlab = "Overlap in time and frequency (%)"
    , lty = c(2,1)
    , xlim = c(0, 60)
    , ylim = c(0, 60)
    , cex.axis = 1.5
    , cex.lab = 2
    , cex = cexs
    , lwd = 2
    , bty = "n"
    , colp = rep(1,nrow(X))
    , bold = "T3"
    , dx = dxs * 3
    , dy = dys * 2.5
   )
rownames(X)
X
```


```{r}
x <- matrix(rnorm(100*3), ncol = 3)
x <- X
stopifnot(mahalanobis(x, 0, diag(ncol(x))) == rowSums(x*x))
        ##- Here, D^2 = usual squared Euclidean distances

Sx <- cov(x)
D2 <- mahalanobis(x, colMeans(x), Sx)
plot(density(D2, bw = 0.5),
     main="Squared Mahalanobis distances, n=100, p=3") ; rug(D2)
qqplot(qchisq(ppoints(100), df = 3), D2,
       main = expression("Q-Q plot of Mahalanobis" * ~D^2 *
                         " vs. quantiles of" * ~ chi[3]^2))
abline(0, 1, col = 'gray')
#
d <- sqrt(D2)
d
p <- 1-exp(-D2/2)
p
1-p
```

Critical values

From: Penny, K. (1996). Appropriate Critical Values When Testing for a Single Multivariate Outlier by Using the Mahalanobis Distance. Journal of the Royal Statistical Society. Series C (Applied Statistics), 45(1), 73-81. doi:10.2307/2986224

```{r}

p <- ncol(X)
n <- nrow(X)
p
n
alpha <- 0.05
cr <- (p*(n-1)^2*qf(alpha/n, p, n-p-1))/
      (n*(n-p-1+p*qf(alpha/n, p, n-p-1)))
cr
#
qchisq(alpha/n,p)
```

```{r}
F <- (n*D2*(n-p))/(p*(n-1)*(n+1))
F
ps <- 1-pf(F,p,n-p)
ps
ps["T3"]
```

Probability that T3 is not an outlier: $p = `r round(ps["T3"],3)`$

---






