---
title: "Regression diagnostics - elipsa"
author: "A. Blejec"
date: "11 8 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, dev=c("pdf","tiff"))
knitr::opts_knit$set(concordance=TRUE)
```


```{r Author:,echo=FALSE}
###############################################
##                                           ##
## (c) Andrej Blejec (andrej.blejec@nib.si)  ##
##                                           ##
###############################################
```

```{r initialize,echo=FALSE,results='hide',message=FALSE}
options(width=70)
#library(Hmisc)
#library(xlsReadWrite)
```
## Data

Data for this example are from the time and area overlap study.


```{r }
Data <- read.table("./out/time_overlap.txt", sep="\t", header = TRUE, row.names = 1)
Data <- Data[,2:1]
X <- Data
X
```

Avgusta (10. 8. 2020) mi je Rok poslal tabelo za drugačno oznako signalov:

```{r }
prepis <- read.table("./data/Oznake.txt", row.names=1, sep="\t",header=TRUE)
prepis
```

Preimenovanje:

```{r }
str(X)
novi <- prepis[rownames(X),1]
cbind(prepis,rownames(X),novi)
rownames(X) <- novi
X
```

Zanimiv je A7, ki je zdaj T3.



```{r }
#####
# Compute points and rotation matrix

# input
#theta <- c(1, 2)
#sigma <- diag(c(3^2, 2^2))
#sigma[2, 1] <- sigma[1, 2] <- sqrt(sigma[1, 1] * sigma[2, 2]) * .5
nellipse <- function(x
    , points = TRUE
    , seg = TRUE
    , q=c(0.05, .25, .50, .75, .95)
    , xlab= names(x)[1]
    , ylab = names(x)[2]
    , ltys=rep(1,length(q))
    , cex =1
    , colp = 1 # barve za points
    , bold = ""
    , ...){
# we start from points on the unit circle
n_points <- 100
n <- nrow(x)
sigma <- cov(x)
theta <- colMeans(x)
X <- sweep(x,2,theta,"-")
xy <- cbind(sin(seq(0, 2 * pi, length.out = n_points)),
            cos(seq(0, 2 * pi, length.out = n_points)))

# then we scale the dimensions
ev <- eigen(sigma)
xy[, 1] <- xy[, 1] * 1
xy[, 2] <- xy[, 2] * sqrt(min(ev$values) / max(ev$values))
# then rotate
phi <- atan(ev$vectors[2, 1] / ev$vectors[1, 1])
R <- matrix(c(cos(phi), sin(phi), -sin(phi), cos(phi)), 2)
xy <- tcrossprod(R, xy)

# the quantiles you ask for
chi_vals <- qchisq(q, df = 2) * max(ev$values)

#####
# Plot contours
par(mar = c(4.5, 4, .5, .5),pty="s")
plot(x[,1],x[,2], type = "n", xlab = xlab, ylab = ylab, asp=1, ...)
for(ii in 1:length(sqrt(chi_vals))) {
  r <- sqrt(chi_vals)[ii]
  lines(r * xy[1, ] + theta[1], r * xy[2, ] + theta[2], lty = ltys[ii], ...)
}
fonts <- rep(1,length=nrow(x))
names(fonts) <- rownames(x)
  if(any(rownames(x)%in% bold)) {
    fonts[bold] <- 2
#    text(x[bold,1],x[bold,2], bold, col=colp, font=2, cex=cex,  ...)
  }
if (points) {text(x[,1],x[,2], rownames(x), col=colp, cex=cex, font=fonts, ...)

}
# Main axis
x1 <- max(sqrt(chi_vals)) * xy[1, ] + theta[1]
y1 <- max(sqrt(chi_vals)) * xy[2, ] + theta[2]
segments(min(x1),min(y1), max(x1), max(y1), col=8)
# second axis
# Main axis
x1 <- max(sqrt(chi_vals)) * xy[1, ] + theta[1]
y1 <- max(sqrt(chi_vals)) * xy[2, ] + theta[2]
segments(min(x1),min(y1), max(x1), max(y1), col=8)

# Deviations

    PCX <- function(X, which=1) {
    PC <- eigen(cov(X))
    PC1 <- as.matrix(X)%*%PC$vectors[,which]
    PCX <- cbind(PC1,0)%*%solve(PC$vectors)
    colnames(PCX) <- paste0("PC",1:ncol(PCX))
    return(PCX)
}
PC <- PCX(X)
PC <- sweep(PC,2,theta,"+")
if(seg){
points(PC[,1],PC[,2],col=2, type="b")
segments(x[,1],x[,2],PC[,1],PC[,2],col=2,lwd=2)
}
invisible(prcomp(x))
}
# enter image description here
#nellipse(X)
#nellipse(X, seg=FALSE, cex=1:2)

```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
tukle se lahko spreminja velikosti črt
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
```{r zeroTruncatedEllipsePercLarge, fig.cap="Ellipses (zero tuncated) encompassing 68% and 95%"}
#tiff("./Elipsa.tif", width=4.75/2, height=2.5, res=300, units="in")
par(mar=c(0.1,0.2,0.1,0.1)*2)
nellipse(X*100
    , q = c(0.68,0.95)
    , seg = FALSE
    , ylab = "Signal overlap in time (%)"
    , xlab = "Signal overlap in time and frequency (%)"
    , lty = c(2,1)
    , xlim = c(0, 50)
    , ylim = c(0, 50)
    , cex.axis = 1.5
    , cex.lab = 2
    , cex = c(1.5, 1.5, 1.5, 2, 1.5, 1.5, 1.5, 1.5)
    , lwd = 2
    , bty = "n"
    , colp = c(1,1,1,1,1,1,1,1)
    , bold = "T3"
   )
#dev.off()
X
```
